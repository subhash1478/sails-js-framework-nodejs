/*** Generated by streamline 0.10.17 (callbacks) - DO NOT EDIT ***/ var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb; var __ = require("underscore");















var crypto = require("crypto");
var util = require("util");
var utils = require("../../../util/utils");
var $ = utils.getLocaleString;
var VNetUtil = require("./../../../util/vnet.util");
var NetworkConfig = require("./networkConfig");

function DnsServer(cli, networkManagementClient) {
  this.networkManagementClient = networkManagementClient;
  this.networkConfig = new NetworkConfig(cli, networkManagementClient);
  this.vnetUtil = new VNetUtil();
  this.output = cli.output;
  this.interaction = cli.interaction;};


__.extend(DnsServer.prototype, {
  list: function list__1(options, _) { var self, networkConfiguration, vnetConfiguration, __this = this; var __frame = { name: "list__1", line: 33 }; return __func(_, this, arguments, list__1, 1, __frame, function __$list__1() { self = __this;


      return self.networkConfig.get(__cb(_, __frame, 3, 50, function ___(__0, __1) { networkConfiguration = __1;
        vnetConfiguration = networkConfiguration.VirtualNetworkConfiguration;

        if ((vnetConfiguration.Dns.DnsServers && (vnetConfiguration.Dns.DnsServers.length > 0))) {
          self.output.table(vnetConfiguration.Dns.DnsServers, function(row, dns) {
            row.cell($("DNS Server ID"), dns.Name);
            row.cell($("IP Address"), dns.IPAddress); }); }

         else {
          if (self.output.format().json) {
            self.output.json([]); }
           else {
            self.output.warn($("No DNS servers found")); } ; } ; _(); }, true)); }); },




  register: function register__2(dnsIp, options, _) { var self, dnsServer, networkConfig, vnetConfig, __this = this; var __frame = { name: "register__2", line: 53 }; return __func(_, this, arguments, register__2, 2, __frame, function __$register__2() { self = __this;


      dnsServer = self._parseDnsServer(dnsIp, options);
      return self.networkConfig.get(__cb(_, __frame, 4, 43, function ___(__0, __1) { networkConfig = __1;

        if (!networkConfig.VirtualNetworkConfiguration) {
          networkConfig.VirtualNetworkConfiguration = { }; } ;


        vnetConfig = networkConfig.VirtualNetworkConfiguration;
        if (!vnetConfig.Dns) {
          vnetConfig.Dns = { }; } ;


        if (!vnetConfig.Dns.DnsServers) {
          vnetConfig.Dns.DnsServers = []; } ;


        if (utils.findFirstCaseIgnore(vnetConfig.Dns.DnsServers, { Name: dnsServer.Name })) {
          return _(new Error(util.format($("A DNS Server with name identifier \"%s\" already exists"), dnsServer.Name))); } ;


        if (utils.findFirstCaseIgnore(vnetConfig.Dns.DnsServers, { IPAddress: dnsServer.IPAddress })) {
          return _(new Error(util.format($("A DNS Server with ip address \"%s\" already exists"), dnsServer.IPAddress))); } ;


        vnetConfig.Dns.DnsServers.push(dnsServer);
        return self.networkConfig.set(networkConfig, __cb(_, __frame, 28, 23, function __$register__2() { _(); }, true)); }, true)); }); },


  unregister: function unregister__3(dnsIp, options, _) { var self, filter, ipValidationResult, networkConfiguration, vnetConfiguration, dnsServer, index, __this = this; var __frame = { name: "unregister__3", line: 84 }; return __func(_, this, arguments, unregister__3, 2, __frame, function __$unregister__3() { self = __this;


      if ((dnsIp && options.dnsId)) {
        return _(new Error($("Either --dns-id or --dns-ip must be present not both"))); } ; return (function __$unregister__3(__then) {


        if ((!dnsIp && !options.dnsId)) {
          return self.interaction.promptIfNotGiven($("DNS IP: "), dnsIp, __cb(_, __frame, 8, 31, function ___(__0, __2) { dnsIp = __2; __then(); }, true)); } else { __then(); } ; })(function __$unregister__3() {



        if (dnsIp) {
          ipValidationResult = self.vnetUtil.parseIPv4(dnsIp);
          if (ipValidationResult.error) {
            return _(new Error(ipValidationResult.error)); } ;

          filter = { IPAddress: dnsIp }; }
         else {
          filter = { Name: options.dnsId }; } ;


        return self.networkConfig.get(__cb(_, __frame, 22, 50, function ___(__0, __3) { networkConfiguration = __3;
          vnetConfiguration = networkConfiguration.VirtualNetworkConfiguration;

          dnsServer = utils.findFirstCaseIgnore(vnetConfiguration.Dns.DnsServers, filter);
          if (!dnsServer) {
            return _(new Error(util.format($("A DNS Server with %s %s not found"), (options.dnsId ? $("name identifier") : $("IP address")), (dnsIp || options.dnsId)))); } ;


          vnetConfiguration.VirtualNetworkSites.forEach(function(site) {
            if (site.DnsServersRef) {
              if (utils.findFirstCaseIgnore(site.DnsServersRef, { Name: dnsServer.Name })) {
                throw new Error(util.format($("You cannot unregister DNS server \"%s\", because it is being referenced by the virtual network \"%s\""), dnsServer.Name, site.Name)); } ; } ; }); return (function __$unregister__3(_) {




            var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return self.interaction.confirm(util.format($("Delete the DNS server \"%s\" (%s)? [y/n] "), dnsServer.Name, dnsServer.IPAddress), __cb(_, __frame, 38, 44, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -83, 17, function ___(__0, __4) { return (function __$unregister__3(__then) { if (__4) { return _(null); } else { __then(); } ; })(function __$unregister__3() {



              index = utils.indexOfCaseIgnore(vnetConfiguration.Dns.DnsServers, filter);
              vnetConfiguration.Dns.DnsServers.splice(index, 1);
              return self.networkConfig.set(networkConfiguration, __cb(_, __frame, 44, 23, function __$unregister__3() { _(); }, true)); }); }, true)); }, true)); }); }); },


  _parseDnsServer: function(dnsIp, options) {
    var self = this;

    var dnsServer = {
      Name: "",
      IPAddress: "" };


    if (options.dnsId) {
      var dnsIdPattern = /^[a-z][a-z0-9\-]{0,19}$/i;
      if ((dnsIdPattern.test(options.dnsId) === false)) {
        throw new Error($("--dns-id can contain only letters, numbers and hyphens with no more than 20 characters. It must start with a letter")); } ;

      dnsServer.Name = options.dnsId; }
     else {
      dnsServer.Name = util.format($("DNS-%s"), crypto.randomBytes(8).toString("hex"));
      self.output.info(util.format($("The name identifier for this DNS server will be \"%s\""), dnsServer.Name)); } ;



    var ipValidationResult = self.vnetUtil.parseIPv4(dnsIp);
    if (ipValidationResult.error) {
      throw new Error(ipValidationResult.error); } ;

    dnsServer.IPAddress = self.vnetUtil.octectsToString(ipValidationResult.octects);

    return dnsServer; }});



module.exports = DnsServer;
