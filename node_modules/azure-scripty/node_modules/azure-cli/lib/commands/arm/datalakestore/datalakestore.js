/*** Generated by streamline 0.10.17 (callbacks) - DO NOT EDIT ***/ "use strict"; var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__catch=__rt.__catch,__tryCatch=__rt.__tryCatch; var util = require("util");
















var fs = require("fs");
var progress = require("progress");
var profile = require("../../../util/profile");
var utils = require("../../../util/utils");
var tagUtils = require("../tag/tagUtils");
var $ = utils.getLocaleString;
var dataLakeStoreUtils = require("./datalakestore.utils");

var readStreamToBuffer = function(strm, callback) {
  var bufs = [];
  strm.on("data", function(d) {
    bufs.push(d); });

  strm.on("end", function() {
    callback(null, Buffer.concat(bufs)); });};



exports.init = function(cli) {
  var log = cli.output;
  var withProgress = cli.interaction.withProgress.bind(cli.interaction);





  var dataLakeCommands = cli.category("datalake").description($("Commands to manage your Data Lake objects"));


  var dataLakeStoreCommands = dataLakeCommands.category("store").description($("Commands to manage your Data Lake Storage objects"));


  var dataLakeStoreFileSystem = dataLakeStoreCommands.category("filesystem").description($("Commands to manage your Data Lake Storage FileSystem"));


  var dataLakeStoreFileSystemExpiry = dataLakeStoreFileSystem.category("expiry").description($("Commands to manage expiration of your Data Lake Storage FileSystem"));


  dataLakeStoreFileSystemExpiry.command("set [accountName] [path]").description($("sets or removes the absolute expiration time of the specified path (files only).")).usage("[options] <accountName> <path>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --path <path>", $("the full path to the folder to list (e.g. /someFolder or /someFolder/someNestedFolder)")).option("-e --expiration <expiration time in ticks since epoch>", $("the expiration time to set for the file. Values <= 0 or >= 253402300800000 indicate the file will never expire.)")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __1(accountName, path, options, _) { var subscription, client, fileStatus, params; var __frame = { name: "__1", line: 63 }; return __func(_, this, arguments, __1, 3, __frame, function __$__1() {







      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!path) {
        return _(null, cli.missingArgument("path")); } ;


      subscription = profile.current.getSubscription(options.subscription);
      client = utils.createDataLakeStoreFileSystemManagementClient(subscription);
      return client.fileSystem.getFileStatus(accountName, path, __cb(_, __frame, 11, 39, function ___(__0, __1) { fileStatus = __1.fileStatus;
        if ((fileStatus.type !== "FILE")) {
          return _(new Error($(("Expiration can only be set on files (not on folders). Please specify a file path with the --path parameter. Path given: " + path)))); } ; return (function __$__1(__then) {


          if (((options.expiration && (parseInt(options.expiration) > 0)) && (parseInt(options.expiration) < 253402300800000))) {

            params = {
              expireTime: parseInt(options.expiration) };


            return client.fileSystem.setFileExpiry(accountName, path, "Absolute", params, __cb(_, __frame, 22, 24, __then, true)); } else {



            return client.fileSystem.setFileExpiry(accountName, path, "NeverExpire", __cb(_, __frame, 26, 24, __then, true)); } ; })(function __$__1() {


          return client.fileSystem.getFileStatus(accountName, path, __cb(_, __frame, 29, 35, function ___(__0, __2) { fileStatus = __2.fileStatus;
            dataLakeStoreUtils.formatOutput(cli, log, options, fileStatus); _(); }, true)); }); }, true)); }); });


  dataLakeStoreFileSystem.command("list [accountName] [path]").description($("Lists the contents of the specified path (files and folders).")).usage("[options] <accountName> <path>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --path <path>", $("the full path to the folder to list (e.g. /someFolder or /someFolder/someNestedFolder)")).option("-l --listSize <listSize>", $("the optional number of entries to list. The default is all entries, which can potentially take some time for large directories.)")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __2(accountName, path, options, _) { var subscription, client, parameters, fileStatuses; var __frame = { name: "__2", line: 103 }; return __func(_, this, arguments, __2, 3, __frame, function __$__2() {







      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!path) {
        return _(null, cli.missingArgument("path")); } ;


      subscription = profile.current.getSubscription(options.subscription);
      client = utils.createDataLakeStoreFileSystemManagementClient(subscription);
      parameters = { };
      if (options.listSize) {
        parameters = {
          listSize: parseInt(options.listSize) }; } ;



      return client.fileSystem.listFileStatus(accountName, path, parameters, __cb(_, __frame, 18, 41, function ___(__0, __1) { fileStatuses = __1.fileStatuses.fileStatus;
        dataLakeStoreUtils.formatOutputList(cli, log, options, fileStatuses); _(); }, true)); }); });


  dataLakeStoreFileSystem.command("show [accountName] [path]").description($("Gets the specified Data Lake Store file or folder details")).usage("[options] <accountName> <path>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --path <path>", $("the full path to the folder or file to get (e.g. /someFolder or /someFolder/someFile.txt)")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __3(accountName, path, options, _) { var subscription, client, fileStatus; var __frame = { name: "__3", line: 131 }; return __func(_, this, arguments, __3, 3, __frame, function __$__3() {






      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!path) {
        return _(null, cli.missingArgument("path")); } ;


      subscription = profile.current.getSubscription(options.subscription);
      client = utils.createDataLakeStoreFileSystemManagementClient(subscription);

      return client.fileSystem.getFileStatus(accountName, path, __cb(_, __frame, 12, 39, function ___(__0, __1) { fileStatus = __1.fileStatus;
        dataLakeStoreUtils.formatOutput(cli, log, options, fileStatus); _(); }, true)); }); });


  dataLakeStoreFileSystem.command("delete [accountName] [path]").description($("deletes the specified Data Lake Store file or folder, with the option for recursive delete (if the folder has contents)")).usage("[options] <accountName> <path>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --path <path>", $("the full path to the folder or file to get (e.g. /someFolder or /someFolder/someFile.txt)")).option("-r --recurse", $("optionally indicates that this should be a recursive delete, which will delete a folder and all contents underneath it.")).option("-q --quiet", $("optionally indicates the delete should be immediately performed with no confirmation or prompting. Use carefully.")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __4(accountName, path, options, _) { var subscription, client, params; var __frame = { name: "__4", line: 155 }; return __func(_, this, arguments, __4, 3, __frame, function __$__4() {








      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!path) {
        return _(null, cli.missingArgument("path")); } ; return (function __$__4(_) {


        var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return cli.interaction.confirm(util.format($("Delete the file or folder at path: %s? [y/n] "), path), __cb(_, __frame, 9, 43, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -154, 17, function ___(__0, __2) { return (function __$__4(__then) { if (__2) { return _(null); } else { __then(); } ; })(function __$__4() {



          subscription = profile.current.getSubscription(options.subscription);
          client = utils.createDataLakeStoreFileSystemManagementClient(subscription);

          params = { };
          if (!options.recurse) {
            params.recursive = false; }

           else {
            params.recursive = true; } ;


          return client.fileSystem.deleteMethod(accountName, path, params, __cb(_, __frame, 24, 22, function __$__4() {
            log.info($(("Successfully deleted the item at path: " + path))); _(); }, true)); }); }, true)); }); });


  dataLakeStoreFileSystem.command("create [accountName] [path]").description($("Creates the specified folder or file, with the option to include content in file creation.")).usage("[options] <accountName> <path>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --path <path>", $("the full path to the file to add content to (e.g. /someFolder/someFile.txt)")).option("-v --value <value>", $("optional indicates the contents (as a string) to create the file with. NOTE: This parameter cannot be specified with --folder (-d)")).option("-d --folder", $("optionally specify that the item being created is a folder, not a file. If this is not specified, a file will be created. NOTE: This parameter cannot be specified with --encoding (-e) or --value (-v)")).option("-f --force", $("optionally indicates that the file or folder being created can overwrite the file or folder at path if it already exists (default is false). 'true' must be passed in for the overwrite to work")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __5(accountName, path, options, _) { var subscription, clientOptions, client, result, parameters; var __frame = { name: "__5", line: 192 }; return __func(_, this, arguments, __5, 3, __frame, function __$__5() {









      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!path) {
        return _(null, cli.missingArgument("path")); } ;


      if (((options.value && options.folder))) {
        return _(new Error($("--folder cannot be specified with --value"))); } ;


      subscription = profile.current.getSubscription(options.subscription);
      clientOptions = {
        disableLogFilter: true };


      client = utils.createDataLakeStoreFileSystemManagementClient(subscription, clientOptions); return (function __$__5(__then) {

        if (options.folder) {
          return client.fileSystem.mkdirs(accountName, path, __cb(_, __frame, 21, 37, function ___(__0, __2) { result = __2;
            if ((result.operationResult !== true)) {
              return _(new Error($("Failed to create the desired directory!"))); } ; __then(); }, true)); } else {



          parameters = { };

          if (options.force) {
            parameters.overwrite = true; }

           else {
            parameters.overwrite = false; } ;


          parameters.permission = null;
          return withProgress(util.format($("Creating file %s"), path), function __1(log, _) { var __frame = { name: "__1", line: 230 }; return __func(_, this, arguments, __1, 1, __frame, function __$__1() {

              if (options.value) {

                parameters.streamContents = new Buffer(options.value); } ;


              return client.fileSystem.create(accountName, path, parameters, __cb(_, __frame, 6, 26, function __$__1() { _(); }, true)); }); }, __cb(_, __frame, 37, 6, __then, true)); } ; })(function __$__5() {



        log.info($(("Successfully created the specified item at path:  " + path))); _(); }); }); });


  dataLakeStoreFileSystem.command("import [accountName] [path] [destination]").description($("Uploads the specified the specified file, to the target destination in an Azure Data Lake.")).usage("[options] <accountName> <path> <destination>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --path <path>", $("the full local path to the file to import (e.g. /someFolder/someFile.txt or C:somefoldersomeFile.txt)")).option("-d --destination <destination>", $("the full path in the Data Lake Store where the file should be imported to (e.g. /someFolder/someFile.txt")).option("-f --force", $("optionally indicates that the file or folder being created can overwrite the file or folder at path if it already exists (default is false). 'true' must be passed in for the overwrite to work")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __6(accountName, path, destination, options, _) { var subscription, clientOptions, client, parameters, fileStats, fileSizeInBytes, maxBytesToRead, fileHandle, maxAttempts, offset, bar, bytesToRead, appendSucceeded, attemptCount, buffer; var __frame = { name: "__6", line: 251 }; return __func(_, this, arguments, __6, 4, __frame, function __$__6() {








      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!path) {
        return _(null, cli.missingArgument("path")); } ;


      if (!destination) {
        return _(null, cli.missingArgument("destination")); } ;


      subscription = profile.current.getSubscription(options.subscription);
      clientOptions = {
        disableLogFilter: true };


      client = utils.createDataLakeStoreFileSystemManagementClient(subscription, clientOptions);

      parameters = { };

      if (options.force) {
        parameters.overwrite = true; }

       else {
        parameters.overwrite = false; } ;


      parameters.permission = null;

      return fs.stat(path, __cb(_, __frame, 31, 23, function ___(__0, __1) { fileStats = __1;
        if (fileStats.isDirectory()) {
          return _(new Error($("Cannot import directories, please specify a valid file path"))); } ;


        log.info($("Uploading file %s to the Data Lake Store location: %s ..."), path, destination);
        fileSizeInBytes = fileStats.size;
        maxBytesToRead = ((8 * 1024) * 1024);

        return fs.open(path, "r", __cb(_, __frame, 40, 24, function ___(__0, __2) { fileHandle = __2;
          maxAttempts = 4; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__6() {

                offset = 0;
                bar = new progress("  uploading [:bar] :percent :etas", {
                  complete: "=",
                  incomplete: " ",
                  width: 40,
                  total: fileSizeInBytes }); return (function __$__6(__then) {


                  if ((fileSizeInBytes === 0)) {

                    return client.fileSystem.create(accountName, destination, __cb(_, __frame, 53, 26, __then, true)); } else { return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$__6() { __more = false;


                        var __6 = (offset < fileSizeInBytes); if (__6) {
                          bytesToRead = maxBytesToRead;
                          if (((offset + maxBytesToRead) > fileSizeInBytes)) {
                            bytesToRead = (fileSizeInBytes - offset); } ;


                          appendSucceeded = false;
                          attemptCount = 0; return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$__6() { __more = false;
                              var __7 = (!appendSucceeded && (attemptCount < maxAttempts)); if (__7) {
                                attemptCount++; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__6() {

                                      buffer = new Buffer(bytesToRead);
                                      return fs.read(fileHandle, buffer, 0, bytesToRead, offset, __cb(_, __frame, 68, 17, function __$__6() { return (function __$__6(__then) {

                                          if ((offset === 0)) {
                                            parameters.streamContents = buffer;
                                            return client.fileSystem.create(accountName, destination, parameters, __cb(_, __frame, 72, 34, __then, true)); } else {


                                            return client.fileSystem.append(accountName, destination, buffer, __cb(_, __frame, 75, 34, __then, true)); } ; })(function __$__6() {


                                          appendSucceeded = true;
                                          offset += bytesToRead;
                                          bar.tick(bytesToRead); __then(); }); }, true)); }); })(function ___(err, __result) { __catch(function __$__6() { if (err) {


                                        if ((attemptCount >= maxAttempts)) {
                                          return _(err); } ;




                                        dataLakeStoreUtils.waitForRetry(attemptCount, true); __then(); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, function __$__6() { while (__more) { __loop(); }; __more = true; }); }); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(function __$__6() { while (__more) { __loop(); }; __more = true; }); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(__then); } ; })(function __$__6() { _(null, null, true); }); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__6() {






                  fs.close(fileHandle); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__6() {


              log.info($(("Successfully created the specified item at path:  " + destination))); _(); }); }); }, true)); }, true)); }); });


  dataLakeStoreFileSystem.command("concat [accountName] [paths] [destination]").description($("Concatenates the specified list of files into the specified destination file.")).usage("[options] <accountName> <paths> <destination>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --paths <paths>", $("a comma seperated list of full paths to concatenate (e.g. '/someFolder/someFile.txt,/somefolder/somefile2.txt,/anotherFolder/newFile.txt')")).option("-d --destination <destination>", $("specify the target file that all of the files in --paths should be concatenated into (e.g /someFolder/targetFile.txt)")).option("-f --force", $("optionally indicates that the file or folder being created can overwrite the file or folder at path if it already exists (default is false). 'true' must be passed in for the overwrite to work")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __7(accountName, paths, destination, force, options, _) { var subscription, client, fileStatus, pathsBuf; var __frame = { name: "__7", line: 361 }; return __func(_, this, arguments, __7, 5, __frame, function __$__7() {








      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!paths) {
        return _(null, cli.missingArgument("paths")); } ;


      if (!destination) {
        return _(null, cli.missingArgument("destination")); } ;


      subscription = profile.current.getSubscription(options.subscription);
      client = utils.createDataLakeStoreFileSystemManagementClient(subscription); return (function __$__7(__then) {

        if (options.force) { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__7() {

                return client.fileSystem.getFileStatus(accountName, destination, __cb(_, __frame, 18, 43, function ___(__0, __2) { fileStatus = __2.fileStatus; return (function __$__7(__then) {
                    if ((fileStatus.type.toLowerCase() === "file")) {
                      return client.fileSystem.deleteMethod(accountName, destination, false, __cb(_, __frame, 20, 28, __then, true)); } else {


                      return _(new Error($("Cannot forcibly concatenate files into a path that is an existing directory. Please use the delete command to remove the directory and try again."))); } ; })(__then); }, true)); }); })(function ___(err, __result) { __catch(function __$__7() { if (err) { __then(); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, __then); }); } else { __then(); } ; })(function __$__7() {







        pathsBuf = new Buffer(("sources=" + paths));
        return withProgress(util.format($("Concatenating specified files into target location: %s"), destination), function __1(log, _) { var __frame = { name: "__1", line: 394 }; return __func(_, this, arguments, __1, 1, __frame, function __$__1() {

            return client.fileSystem.msConcat(accountName, destination, pathsBuf, false, __cb(_, __frame, 1, 24, function __$__1() { _(); }, true)); }); }, __cb(_, __frame, 32, 4, function __$__7() {

          log.info($(("Successfully concatenated the file list into the specified item at path:  " + destination))); _(); }, true)); }); }); });


  dataLakeStoreFileSystem.command("move [accountName] [path] [destination]").description($("Moves (renames) the specified file or folder into the specified destination file or folder.")).usage("[options] <accountName> <path> <destination>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --path <path>", $("the path to the file or folder to move (e.g. /someFolder or /someFolder/someFile.txt)")).option("-d --destination <destination>", $("specify the target location to move the file or folder to")).option("-f --force", $("optionally indicates that the file or folder being created can overwrite the file or folder at path if it already exists (default is false). 'true' must be passed in for the overwrite to work")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __8(accountName, path, destination, options, _) { var subscription, client; var __frame = { name: "__8", line: 408 }; return __func(_, this, arguments, __8, 4, __frame, function __$__8() {








      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!path) {
        return _(null, cli.missingArgument("paths")); } ;


      if (!destination) {
        return _(null, cli.missingArgument("destination")); } ;


      subscription = profile.current.getSubscription(options.subscription);
      client = utils.createDataLakeStoreFileSystemManagementClient(subscription); return (function __$__8(__then) {

        if (options.force) { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__8() {

                return client.fileSystem.deleteMethod(accountName, destination, true, __cb(_, __frame, 18, 26, __then, true)); }); })(function ___(err, __result) { __catch(function __$__8() { if (err) { __then(); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, __then); }); } else { __then(); } ; })(function __$__8() {






        return client.fileSystem.rename(accountName, path, destination, __cb(_, __frame, 25, 22, function __$__8() {
          log.info($(("Successfully moved the file or folder to: " + destination))); _(); }, true)); }); }); });


  dataLakeStoreFileSystem.command("addcontent [accountName] [path] [value]").description($("Appends the specified content to the end of the Data Lake Store file path specified.")).usage("[options] <accountName> <path> <value>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --path <path>", $("the full path to the file to add content to (e.g. /someFolder/someFile.txt)")).option("-v --value <value>", $("the contents to append to the file")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __9(accountName, path, value, options, _) { var subscription, clientOptions, client; var __frame = { name: "__9", line: 444 }; return __func(_, this, arguments, __9, 4, __frame, function __$__9() {







      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!path) {
        return _(null, cli.missingArgument("path")); } ;


      if (!value) {
        return _(null, cli.missingArgument("value")); } ;


      subscription = profile.current.getSubscription(options.subscription);

      clientOptions = {
        disableLogFilter: true };


      client = utils.createDataLakeStoreFileSystemManagementClient(subscription, clientOptions);
      return withProgress(util.format($("Adding specified content to file %s"), path), function __1(log, _) { var __frame = { name: "__1", line: 465 }; return __func(_, this, arguments, __1, 1, __frame, function __$__1() {

          return client.fileSystem.append(accountName, path, value, __cb(_, __frame, 1, 24, function __$__1() { _(); }, true)); }); }, __cb(_, __frame, 20, 4, function __$__9() {

        log.info($(("Successfully appended content at the specified path:  " + path))); _(); }, true)); }); });


  dataLakeStoreFileSystem.command("export [accountName] [path] [destination]").description($("Downloads the specified file to the target location.")).usage("[options] <accountName> <path> <destination>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --path <path>", $("the full path in the Data Lake Store where the file should be imported to (e.g. /someFolder/someFile.txt")).option("-d --destination <destination>", $("the full local path to the file to import (e.g. /someFolder/someFile.txt or C:somefoldersomeFile.txt)")).option("-f --force", $("optionally indicates that the file being created can overwrite the file at path if it already exists (default is false).")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __10(accountName, path, destination, options, _) { var subscription, client, maxBytesToRead, fileStatus, fileSizeInBytes, fileHandle, offset, maxAttempts, bar, bytesToRead, parameters, attemptCount, readSucceeded, response, buff; var __frame = { name: "__10", line: 479 }; return __func(_, this, arguments, __10, 4, __frame, function __$__10() {








      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!path) {
        return _(null, cli.missingArgument("path")); } ;


      if (!destination) {
        return _(null, cli.missingArgument("destination")); } ;


      subscription = profile.current.getSubscription(options.subscription);
      client = utils.createDataLakeStoreFileSystemManagementClient(subscription);
      maxBytesToRead = ((8 * 1024) * 1024);
      return client.fileSystem.getFileStatus(accountName, path, __cb(_, __frame, 16, 39, function ___(__0, __1) { fileStatus = __1.fileStatus;

        log.info($("Downloading file %s to the specified location: %s"), path, destination);

        fileSizeInBytes = fileStatus.length; return (function __$__10(__then) {

          if (options.force) {
            return fs.open(destination, "w", __cb(_, __frame, 23, 22, function ___(__0, __2) { fileHandle = __2; __then(); }, true)); } else { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__10() {



                  return fs.open(destination, "wx", __cb(_, __frame, 27, 24, function ___(__0, __3) { fileHandle = __3; __then(); }, true)); }); })(function ___(err, __result) { __catch(function __$__10() { if (err) {


                    return _(new Error($(((("The file at path: " + destination) + " already exists. Please use the --force option to overwrite this file. Actual error reported: ") + err)))); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, __then); }); } ; })(function __$__10() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__10() { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__10() {



                      offset = 0;
                      maxAttempts = 4;
                      bar = new progress("  downloading [:bar] :percent :etas", {
                        complete: "=",
                        incomplete: " ",
                        width: 40,
                        total: fileSizeInBytes }); return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$__10() { __more = false;


                          var __9 = (offset < fileSizeInBytes); if (__9) {
                            bytesToRead = maxBytesToRead;
                            if (((offset + maxBytesToRead) > fileSizeInBytes)) {
                              bytesToRead = (fileSizeInBytes - offset); } ;


                            parameters = {
                              length: bytesToRead,
                              offset: offset };


                            attemptCount = 0;
                            readSucceeded = false; return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$__10() { __more = false;
                                var __10 = (!readSucceeded && (attemptCount < maxAttempts)); if (__10) { return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__10() {

                                        return client.fileSystem.open(accountName, path, parameters, __cb(_, __frame, 58, 45, function ___(__0, __4) { response = __4;
                                          return readStreamToBuffer(response, __cb(_, __frame, 59, 23, function ___(__0, __5) { buff = __5;
                                            return fs.write(fileHandle, buff, 0, bytesToRead, offset, __cb(_, __frame, 60, 15, function __$__10() {
                                              readSucceeded = true;
                                              offset += bytesToRead;
                                              bar.tick(bytesToRead); __then(); }, true)); }, true)); }, true)); }); })(function ___(err, __result) { __catch(function __$__10() { if (err) {


                                          if ((attemptCount >= maxAttempts)) {
                                            return _(err); } ;




                                          dataLakeStoreUtils.waitForRetry(attemptCount, true); __then(); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, function __$__10() { while (__more) { __loop(); }; __more = true; }); }); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(function __$__10() { while (__more) { __loop(); }; __more = true; }); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(__then); }); })(function ___(err, __result) { __catch(function __$__10() { if (err) {





                        log.info(err); __then(); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, function __$__10() { _(null, null, true); }); }); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__10() {


                  fs.close(fileHandle); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__10() {


              log.info($(((("Successfully downloaded the specified item at path:  " + path) + " to local path: ") + destination))); _(); }); }); }); }, true)); }); });


  dataLakeStoreFileSystem.command("read [accountName] [path]").description($("Previews the specified Data Lake Store file starting at index 0 (or the specified offset) until the length is reached, displaying the results to the console.")).usage("[options] <accountName> <path>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --path <path>", $("the full path to the file to download (e.g. /someFolder/someFile.txt)")).option("-l --length <length>", $("optionally specify the length, in bytes, to read from the file. If not specified will attempt to display all content after offset. If that length is greater than 1MB a length must be specified.")).option("-o --offset <offset>", $("the optional offset to begin reading at (default is 0)")).option("-f --force", $("optionally forces previewing of a full file. Use with caution, as this can cause instability and hangs with very large files.")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __11(accountName, path, options, _) { var parameters, maxLength, subscription, client, fileInfo, length, response, buff; var __frame = { name: "__11", line: 575 }; return __func(_, this, arguments, __11, 3, __frame, function __$__11() {









      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!path) {
        return _(null, cli.missingArgument("path")); } ;


      if ((options.offset && (parseInt(options.offset) < 0))) {
        return _(new Error($(("--offset must be greater than or equal to 0. Value passed in: " + options.offset)))); } ;


      parameters = { };
      if (options.offset) {
        parameters.offset = parseInt(options.offset); }

       else {
        parameters.offset = 0; } ;


      maxLength = ((1 * 1024) * 1024);
      subscription = profile.current.getSubscription(options.subscription);
      client = utils.createDataLakeStoreFileSystemManagementClient(subscription);
      return client.fileSystem.getFileStatus(accountName, path, __cb(_, __frame, 24, 37, function ___(__0, __2) { fileInfo = __2;
        length = 0;
        if ((!options.length || (options.length <= 0))) {
          length = (fileInfo.length - parameters.offset); }

         else {
          length = parseInt(options.length); } ;


        if ((parameters.offset >= fileInfo.length)) {
          return _(new Error($(((("--offset must be less than than the length of the file. File length: " + fileInfo.length) + ". Value passed in: ") + options.offset)))); } ;



        if (((fileInfo.length - parameters.offset) < length)) {
          length = (fileInfo.length - parameters.offset); } ;


        if (((length > maxLength) && !options.force)) {
          return _(new Error($(((("The remaining data to preview is greater than " + maxLength) + " bytes. Please specify a length or use the --force parameter to preview the entire file. The length of the file that would have been previewed: ") + length)))); } ;


        parameters.length = length;


        return withProgress(util.format($("Previewing contents of file %s"), path), function __1(log, _) { var __frame = { name: "__1", line: 625 }; return __func(_, this, arguments, __1, 1, __frame, function __$__1() {


            return client.fileSystem.open(accountName, path, parameters, __cb(_, __frame, 2, 35, function ___(__0, __1) { response = __1; _(); }, true)); }); }, __cb(_, __frame, 49, 4, function __$__11() {


          return readStreamToBuffer(response, __cb(_, __frame, 55, 15, function ___(__0, __3) { buff = __3;
            log.data(buff.toString()); _(); }, true)); }, true)); }, true)); }); });


  var dataLakeStoreFileSystemPermissions = dataLakeStoreCommands.category("permissions").description($("Commands to manage your Data Lake Storage FileSystem Permissions"));


  dataLakeStoreFileSystemPermissions.command("show [accountName] [path]").description($("Gets the specified Data Lake Store folder ACL")).usage("[options] <accountName> <path>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --path <path>", $("the full path to the folder or file to get (e.g. /someFolder or /someFolder/someFile.txt)")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __12(accountName, path, options, _) { var subscription, client, aclStatus; var __frame = { name: "__12", line: 643 }; return __func(_, this, arguments, __12, 3, __frame, function __$__12() {






      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!path) {
        return _(null, cli.missingArgument("path")); } ;


      subscription = profile.current.getSubscription(options.subscription);
      client = utils.createDataLakeStoreFileSystemManagementClient(subscription);

      return client.fileSystem.getAclStatus(accountName, path, __cb(_, __frame, 12, 38, function ___(__0, __1) { aclStatus = __1.aclStatus;
        dataLakeStoreUtils.formatOutput(cli, log, options, aclStatus); _(); }, true)); }); });


  dataLakeStoreFileSystemPermissions.command("delete [accountName] [path]").description($("Deletes the entire ACL associated with a folder (not including un-named ACL entries)")).usage("[options] <accountName> <path>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --path <path>", $("the full path to the folder to remove ACLs from (e.g. /someFolder)")).option("-d --defaultAcl", $("optionally indicates that the default ACL should be removed instead of the regular ACL. Default is false.")).option("-q, --quiet", $("quiet mode (do not ask for delete confirmation)")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __13(accountName, path, options, _) { var subscription, client; var __frame = { name: "__13", line: 667 }; return __func(_, this, arguments, __13, 3, __frame, function __$__13() {








      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!path) {
        return _(null, cli.missingArgument("path")); } ; return (function __$__13(_) {


        var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return cli.interaction.confirm(util.format($("Delete Data Lake Store ACLs for account %s at path %s? [y/n] "), accountName, path), __cb(_, __frame, 9, 43, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -666, 17, function ___(__0, __2) { return (function __$__13(__then) { if (__2) { return _(null); } else { __then(); } ; })(function __$__13() {



          subscription = profile.current.getSubscription(options.subscription);
          client = utils.createDataLakeStoreFileSystemManagementClient(subscription); return (function __$__13(__then) {

            if (options.defaultAcl) {
              return client.fileSystem.removeDefaultAcl(accountName, path, __cb(_, __frame, 17, 24, __then, true)); } else {


              return client.fileSystem.removeAcl(accountName, path, __cb(_, __frame, 20, 24, __then, true)); } ; })(function __$__13() {

            log.info($("Successfully removed the specified ACL")); _(); }); }); }, true)); }); });


  var dataLakeStoreFileSystemPermissionsEntries = dataLakeStoreFileSystemPermissions.category("entry").description($("Commands to manage your Data Lake Storage FileSystem granular permissions entries"));


  dataLakeStoreFileSystemPermissionsEntries.command("delete [accountName] [path] [aclEntries]").description($("deletes the specific ACE entry or entries from the path")).usage("[options] <accountName> <path> <aclEntries>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --path <path>", $("the full path to the folder to remove ACEs from (e.g. /someFolder)")).option("-a --aclEntries <aclEntries>", $("a comma delimited list of the fully qualified ACE entry or entries to delete in the format [default:]<user>|<group>:<object Id> (e.g 'user:5546499e-795f-4f5f-b411-8179051f8b0a' or 'default:group:5546499e-795f-4f5f-b411-8179051f8b0a')")).option("-q, --quiet", $("quiet mode (do not ask for delete confirmation)")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __14(accountName, path, aclEntries, options, _) { var subscription, client; var __frame = { name: "__14", line: 703 }; return __func(_, this, arguments, __14, 4, __frame, function __$__14() {








      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!path) {
        return _(null, cli.missingArgument("path")); } ;


      if (!aclEntries) {
        return _(null, cli.missingArgument("aclEntries")); } ; return (function __$__14(_) {


        var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return cli.interaction.confirm(util.format($("Delete Data Lake Store ACL entries: %s for account %s at path %s? [y/n] "), aclEntries, accountName, path), __cb(_, __frame, 13, 43, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -702, 17, function ___(__0, __2) { return (function __$__14(__then) { if (__2) { return _(null); } else { __then(); } ; })(function __$__14() {



          subscription = profile.current.getSubscription(options.subscription);
          client = utils.createDataLakeStoreFileSystemManagementClient(subscription);

          return client.fileSystem.removeAclEntries(accountName, path, aclEntries, __cb(_, __frame, 20, 22, function __$__14() {
            log.info($("Successfully removed the specified ACL entries")); _(); }, true)); }); }, true)); }); });


  dataLakeStoreFileSystemPermissionsEntries.command("set [accountName] [path] [aclEntries]").description($("sets the specified Data Lake Store folder ACE entry or entries")).usage("[options] <accountName> <path> <aclEntries>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --path <path>", $("the full path to the folder to set ACEs on (e.g. /someFolder)")).option("-a --aclEntries <aclEntries>", $("a comma delimited list of the fully qualified ACE entries to set in the format [default:]<user>|<group>:<object Id>:<permissions> (e.g 'user:5546499e-795f-4f5f-b411-8179051f8b0a:r-x' or 'default:group:5546499e-795f-4f5f-b411-8179051f8b0a:rwx')")).option("-q, --quiet", $("quiet mode (do not ask for overwrite confirmation)")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __15(accountName, path, aclEntries, options, _) { var subscription, client; var __frame = { name: "__15", line: 735 }; return __func(_, this, arguments, __15, 4, __frame, function __$__15() {








      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!path) {
        return _(null, cli.missingArgument("path")); } ;


      if (!aclEntries) {
        return _(null, cli.missingArgument("aclEntries")); } ; return (function __$__15(_) {


        var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return cli.interaction.confirm(util.format($("Potentially overwrite existing Data Lake Store ACL entries: %s for account %s at path %s? [y/n] "), aclEntries, accountName, path), __cb(_, __frame, 13, 43, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -734, 17, function ___(__0, __2) { return (function __$__15(__then) { if (__2) { return _(null); } else { __then(); } ; })(function __$__15() {



          subscription = profile.current.getSubscription(options.subscription);
          client = utils.createDataLakeStoreFileSystemManagementClient(subscription);

          return client.fileSystem.modifyAclEntries(accountName, path, aclEntries, __cb(_, __frame, 20, 22, function __$__15() {
            log.info($("Successfully set the specified ACL entries")); _(); }, true)); }); }, true)); }); });


  dataLakeStoreFileSystemPermissions.command("set [accountName] [path] [aclSpec]").description($("sets the specified Data Lake Store folder ACL (overwriting the previous ACL entries)")).usage("[options] <accountName> <path> <aclSpec>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-p --path <path>", $("the full path to the folder to remove ACLs from (e.g. /someFolder)")).option("-a --aclSpec <aclSpec>", $("a comma delimited list of fully qualified ACL entries to set in the format [default:]<user>|<group>:<object Id>:<permissions> (e.g 'user:5546499e-795f-4f5f-b411-8179051f8b0a:r-x' or 'default:group:5546499e-795f-4f5f-b411-8179051f8b0a:rwx'). This list must also include default entries (no object ID in the middle)")).option("-q, --quiet", $("quiet mode (do not ask for overwrite confirmation)")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __16(accountName, path, aclSpec, options, _) { var subscription, client; var __frame = { name: "__16", line: 767 }; return __func(_, this, arguments, __16, 4, __frame, function __$__16() {








      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!path) {
        return _(null, cli.missingArgument("path")); } ;


      if (!aclSpec) {
        return _(null, cli.missingArgument("aclSpec")); } ; return (function __$__16(_) {


        var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return cli.interaction.confirm(util.format($("Overwrite existing Data Lake Store ACL with the following ACL: %s for account %s at path %s? [y/n] "), aclSpec, accountName, path), __cb(_, __frame, 13, 43, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -766, 17, function ___(__0, __2) { return (function __$__16(__then) { if (__2) { return _(null); } else { __then(); } ; })(function __$__16() {



          subscription = profile.current.getSubscription(options.subscription);
          client = utils.createDataLakeStoreFileSystemManagementClient(subscription);

          return client.fileSystem.setAcl(accountName, path, aclSpec, __cb(_, __frame, 20, 22, function __$__16() {
            log.info($("Successfully set the ACL")); _(); }, true)); }); }, true)); }); });


  var dataLakeStoreFirewallRules = dataLakeStoreCommands.category("firewall").description($("Commands to manage your Data Lake Storage account firewall rules"));


  dataLakeStoreFirewallRules.command("create [accountName] [name] [startIpAddress] [endIpAddress]").description($("adds the specified firewall rule to the specified Data Lake Store account.")).usage("[options] <accountName> <name> <startIpAddress> <endIpAddress>").option("-a --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-n --name <firewall rule name>", $("the name of the firewall rule to add")).option("-t --startIpAddress <start ip address>", $("the start of the valid ip range for the firewall rule")).option("-e, --endIpAddress <end ip address>", $("the end of the valid ip range for the firewall rule")).option("-g --resource-group <resource-group>", $("optionally explicitly set the resource group. If not specified, will attempt to discover it.")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __17(accountName, name, startIpAddress, endIpAddress, options, _) { var subscription, client, parameters, result; var __frame = { name: "__17", line: 803 }; return __func(_, this, arguments, __17, 5, __frame, function __$__17() {









      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!name) {
        return _(null, cli.missingArgument("name")); } ;


      if (!startIpAddress) {
        return _(null, cli.missingArgument("startIpAddress")); } ;


      if (!endIpAddress) {
        return _(null, cli.missingArgument("endIpAddress")); } ;


      subscription = profile.current.getSubscription(options.subscription); return (function __$__17(__then) {

        if (!options.resourceGroup) {
          return getResourceGroupByAccountName(subscription, options.resourceGroup, accountName, __cb(_, __frame, 20, 30, function ___(__0, __1) { options.resourceGroup = __1; __then(); }, true)); } else { __then(); } ; })(function __$__17() {


        client = utils.createDataLakeStoreManagementClient(subscription);
        parameters = {
          startIpAddress: startIpAddress,
          endIpAddress: endIpAddress };


        return client.firewallRules.createOrUpdate(options.resourceGroup, accountName, name, parameters, __cb(_, __frame, 29, 38, function ___(__0, __2) { result = __2;
          dataLakeStoreUtils.formatOutput(cli, log, options, result); _(); }, true)); }); }); });


  dataLakeStoreFirewallRules.command("set [accountName] [name]").description($("updates the specified firewall rule in the specified Data Lake Store account.")).usage("[options] <accountName> <name>").option("-a --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-n --name <firewall rule name>", $("the name of the firewall rule to update")).option("-t --startIpAddress <start ip address>", $("the optional new start of the valid ip range for the firewall rule")).option("-e, --endIpAddress <end ip address>", $("the optional new end of the valid ip range for the firewall rule")).option("-g --resource-group <resource-group>", $("optionally explicitly set the resource group. If not specified, will attempt to discover it.")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __18(accountName, name, options, _) { var subscription, client, currentRule, parameters, result; var __frame = { name: "__18", line: 845 }; return __func(_, this, arguments, __18, 3, __frame, function __$__18() {









      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!name) {
        return _(null, cli.missingArgument("name")); } ;


      subscription = profile.current.getSubscription(options.subscription); return (function __$__18(__then) {

        if (!options.resourceGroup) {
          return getResourceGroupByAccountName(subscription, options.resourceGroup, accountName, __cb(_, __frame, 12, 30, function ___(__0, __1) { options.resourceGroup = __1; __then(); }, true)); } else { __then(); } ; })(function __$__18() {


        client = utils.createDataLakeStoreManagementClient(subscription);
        return client.firewallRules.get(options.resourceGroup, accountName, name, __cb(_, __frame, 16, 43, function ___(__0, __2) { currentRule = __2;
          if (!options.startIpAddress) {
            options.startIpAddress = currentRule.startIpAddress; } ;


          if (!options.endIpAddress) {
            options.endIpAddress = currentRule.endIpAddress; } ;


          parameters = {
            startIpAddress: options.startIpAddress,
            endIpAddress: options.endIpAddress };


          return client.firewallRules.createOrUpdate(options.resourceGroup, accountName, name, parameters, __cb(_, __frame, 30, 38, function ___(__0, __3) { result = __3;
            dataLakeStoreUtils.formatOutput(cli, log, options, result); _(); }, true)); }, true)); }); }); });


  dataLakeStoreFirewallRules.command("show [accountName] [name]").description($("retrieves the specified firewall rule in the specified Data Lake Store account.")).usage("[options] <accountName> <name>").option("-a --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-g --resource-group <resource-group>", $("optionally explicitly set the resource group. If not specified, will attempt to discover it.")).option("-n --name <firewall rule name>", $("the name of the firewall rule to display")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __19(accountName, name, options, _) { var subscription, client, currentRule; var __frame = { name: "__19", line: 886 }; return __func(_, this, arguments, __19, 3, __frame, function __$__19() {







      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!name) {
        return _(null, cli.missingArgument("name")); } ;


      subscription = profile.current.getSubscription(options.subscription); return (function __$__19(__then) {

        if (!options.resourceGroup) {
          return getResourceGroupByAccountName(subscription, options.resourceGroup, accountName, __cb(_, __frame, 12, 30, function ___(__0, __1) { options.resourceGroup = __1; __then(); }, true)); } else { __then(); } ; })(function __$__19() {


        client = utils.createDataLakeStoreManagementClient(subscription);
        return client.firewallRules.get(options.resourceGroup, accountName, name, __cb(_, __frame, 16, 43, function ___(__0, __2) { currentRule = __2;
          dataLakeStoreUtils.formatOutput(cli, log, options, currentRule); _(); }, true)); }); }); });


  dataLakeStoreFirewallRules.command("list [accountName]").description($("retrieves all firewall rules in the specified Data Lake Store account.")).usage("[options] <accountName>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-g --resource-group <resource-group>", $("optionally explicitly set the resource group. If not specified, will attempt to discover it.")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __20(accountName, options, _) { var subscription, client, response, rules; var __frame = { name: "__20", line: 912 }; return __func(_, this, arguments, __20, 2, __frame, function __$__20() {






      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      subscription = profile.current.getSubscription(options.subscription); return (function __$__20(__then) {

        if (!options.resourceGroup) {
          return getResourceGroupByAccountName(subscription, options.resourceGroup, accountName, __cb(_, __frame, 8, 30, function ___(__0, __1) { options.resourceGroup = __1; __then(); }, true)); } else { __then(); } ; })(function __$__20() {


        client = utils.createDataLakeStoreManagementClient(subscription);
        return client.firewallRules.listByAccount(options.resourceGroup, accountName, __cb(_, __frame, 12, 40, function ___(__0, __2) { response = __2;
          rules = response; return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$__20() { __more = false;
              var __6 = response.nextLink; if (__6) {
                return client.firewallRules.listByAccountNext(response.nextLink, __cb(_, __frame, 15, 38, function ___(__0, __3) { response = __3;
                  rules.push.apply(rules, response); while (__more) { __loop(); }; __more = true; }, true)); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(function __$__20() {


            dataLakeStoreUtils.formatOutputList(cli, log, options, rules); _(); }); }, true)); }); }); });


  dataLakeStoreFirewallRules.command("delete [accountName] [name]").description($("removes the specified firewall rule in the specified Data Lake Store account.")).usage("[options] <accountName> <name>").option("-a --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-g --resource-group <resource-group>", $("the optional resource group to list the accounts in")).option("-n --name <firewall rule name>", $("the name of the firewall rule to delete")).option("-q, --quiet", $("quiet mode (do not ask for delete confirmation)")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __21(accountName, name, options, _) { var subscription, client; var __frame = { name: "__21", line: 942 }; return __func(_, this, arguments, __21, 3, __frame, function __$__21() {








      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!name) {
        return _(null, cli.missingArgument("name")); } ; return (function __$__21(_) {


        var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return cli.interaction.confirm(util.format($("Delete firewall rule %s in Data Lake Store account %s? [y/n] "), name, accountName), __cb(_, __frame, 9, 43, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -941, 17, function ___(__0, __2) { return (function __$__21(__then) { if (__2) { return _(null); } else { __then(); } ; })(function __$__21() {



          subscription = profile.current.getSubscription(options.subscription); return (function __$__21(__then) {

            if (!options.resourceGroup) {
              return getResourceGroupByAccountName(subscription, options.resourceGroup, accountName, __cb(_, __frame, 16, 30, function ___(__0, __3) { options.resourceGroup = __3; __then(); }, true)); } else { __then(); } ; })(function __$__21() {


            client = utils.createDataLakeStoreManagementClient(subscription);
            return client.firewallRules.deleteMethod(options.resourceGroup, accountName, name, __cb(_, __frame, 20, 25, function __$__21() {

              log.info($("Successfully deleted the specified firewall rule.")); _(); }, true)); }); }); }, true)); }); });


  var dataLakeStoreTrustedIdProvider = dataLakeStoreCommands.category("provider").description($("Commands to manage your Data Lake Storage account trusted identity providers"));


  dataLakeStoreTrustedIdProvider.command("create [accountName] [name] [providerEndpoint]").description($("adds the specified trusted identity provider to the specified Data Lake Store account.")).usage("[options] <accountName> <name> <providerEndpoint>").option("-a --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-g --resource-group <resource-group>", $("optionally explicitly set the resource group. If not specified, will attempt to discover it.")).option("-n --name <trusted identity provider name>", $("the name of the trusted identity provider to add")).option("-e, --providerEndpoint <endpoint>", $("the valid trusted provider endpoint in the format: https://sts.windows.net/<provider identity>")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __22(accountName, name, providerEndpoint, options, _) { var __frame = { name: "__22", line: 978 }; return __func(_, this, arguments, __22, 4, __frame, function __$__22() {








      return createOrUpdateTrustedIdProvider(cli, accountName, options.resourceGroup, name, providerEndpoint, options, __cb(_, __frame, 1, 4, function __$__22() { _(); }, true)); }); });


  dataLakeStoreTrustedIdProvider.command("set [accountName] [name] [providerEndpoint]").description($("updates the specified trusted identity provider in the specified Data Lake Store account.")).usage("[options] <accountName> <name> <providerEndpoint>").option("-a --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-g --resource-group <resource-group>", $("optionally explicitly set the resource group. If not specified, will attempt to discover it.")).option("-n --name <trusted identity provider name>", $("the name of the trusted identity provider to update")).option("-e, --providerEndpoint <endpoint>", $("the new valid trusted provider endpoint in the format: https://sts.windows.net/<provider identity>")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __23(accountName, name, providerEndpoint, options, _) { var __frame = { name: "__23", line: 990 }; return __func(_, this, arguments, __23, 4, __frame, function __$__23() {








      return createOrUpdateTrustedIdProvider(cli, accountName, options.resourceGroup, name, providerEndpoint, options, __cb(_, __frame, 1, 4, function __$__23() { _(); }, true)); }); });


  dataLakeStoreTrustedIdProvider.command("show [accountName] [name]").description($("retrieves the specified trusted identity provider in the specified Data Lake Store account.")).usage("[options] <accountName> <name>").option("-a --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-g --resource-group <resource-group>", $("optionally explicitly set the resource group. If not specified, will attempt to discover it.")).option("-n --name <trusted identity provider name>", $("the name of the trusted identity provider to display")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __24(accountName, name, options, _) { var subscription, client, currentRule; var __frame = { name: "__24", line: 1001 }; return __func(_, this, arguments, __24, 3, __frame, function __$__24() {







      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!name) {
        return _(null, cli.missingArgument("name")); } ;


      subscription = profile.current.getSubscription(options.subscription); return (function __$__24(__then) {

        if (!options.resourceGroup) {
          return getResourceGroupByAccountName(subscription, options.resourceGroup, accountName, __cb(_, __frame, 12, 30, function ___(__0, __1) { options.resourceGroup = __1; __then(); }, true)); } else { __then(); } ; })(function __$__24() {


        client = utils.createDataLakeStoreManagementClient(subscription);
        return client.trustedIdProviders.get(options.resourceGroup, accountName, name, __cb(_, __frame, 16, 48, function ___(__0, __2) { currentRule = __2;
          dataLakeStoreUtils.formatOutput(cli, log, options, currentRule); _(); }, true)); }); }); });


  dataLakeStoreTrustedIdProvider.command("list [accountName]").description($("retrieves all trusted identity providers in the specified Data Lake Store account.")).usage("[options] <accountName>").option("-n --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-g --resource-group <resource-group>", $("optionally explicitly set the resource group. If not specified, will attempt to discover it.")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __25(accountName, options, _) { var subscription, client, response, rules; var __frame = { name: "__25", line: 1027 }; return __func(_, this, arguments, __25, 2, __frame, function __$__25() {






      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      subscription = profile.current.getSubscription(options.subscription); return (function __$__25(__then) {

        if (!options.resourceGroup) {
          return getResourceGroupByAccountName(subscription, options.resourceGroup, accountName, __cb(_, __frame, 8, 30, function ___(__0, __1) { options.resourceGroup = __1; __then(); }, true)); } else { __then(); } ; })(function __$__25() {


        client = utils.createDataLakeStoreManagementClient(subscription);
        return client.trustedIdProviders.listByAccount(options.resourceGroup, accountName, __cb(_, __frame, 12, 45, function ___(__0, __2) { response = __2;
          rules = response; return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$__25() { __more = false;
              var __6 = response.nextLink; if (__6) {
                return client.trustedIdProviders.listByAccountNext(response.nextLink, __cb(_, __frame, 15, 43, function ___(__0, __3) { response = __3;
                  rules.push.apply(rules, response); while (__more) { __loop(); }; __more = true; }, true)); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(function __$__25() {


            dataLakeStoreUtils.formatOutputList(cli, log, options, rules); _(); }); }, true)); }); }); });


  dataLakeStoreTrustedIdProvider.command("delete [accountName] [name]").description($("removes the specified trusted identity provider in the specified Data Lake Store account.")).usage("[options] <accountName> <name>").option("-a --accountName <accountName>", $("the Data Lake Store account name to execute the action on")).option("-g --resource-group <resource-group>", $("the optional resource group to list the accounts in")).option("-n --name <trusted identity provider name>", $("the name of the trusted identity provider to delete")).option("-q, --quiet", $("quiet mode (do not ask for delete confirmation)")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __26(accountName, name, options, _) { var subscription, client; var __frame = { name: "__26", line: 1057 }; return __func(_, this, arguments, __26, 3, __frame, function __$__26() {








      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!name) {
        return _(null, cli.missingArgument("name")); } ; return (function __$__26(_) {


        var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return cli.interaction.confirm(util.format($("Delete trusted identity provider %s in Data Lake Store account %s? [y/n] "), name, accountName), __cb(_, __frame, 9, 43, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -1056, 17, function ___(__0, __2) { return (function __$__26(__then) { if (__2) { return _(null); } else { __then(); } ; })(function __$__26() {



          subscription = profile.current.getSubscription(options.subscription); return (function __$__26(__then) {

            if (!options.resourceGroup) {
              return getResourceGroupByAccountName(subscription, options.resourceGroup, accountName, __cb(_, __frame, 16, 30, function ___(__0, __3) { options.resourceGroup = __3; __then(); }, true)); } else { __then(); } ; })(function __$__26() {


            client = utils.createDataLakeStoreManagementClient(subscription);
            return client.trustedIdProviders.deleteMethod(options.resourceGroup, accountName, name, __cb(_, __frame, 20, 30, function __$__26() {

              log.info($("Successfully deleted the specified trusted identity provider.")); _(); }, true)); }); }); }, true)); }); });


  var dataLakeStoreAccount = dataLakeStoreCommands.category("account").description($("Commands to manage your Data Lake Storage accounts"));


  dataLakeStoreAccount.command("list").description($("List all Data Lake Store accounts available for your subscription or subscription and resource group")).usage("[options]").option("-g --resource-group <resource-group>", $("the optional resource group to list the accounts in")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __27(options, _) { var subscription, accounts; var __frame = { name: "__27", line: 1090 }; return __func(_, this, arguments, __27, 1, __frame, function __$__27() {





      subscription = profile.current.getSubscription(options.subscription);
      return listAllDataLakeStoreAccounts(subscription, options.resourceGroup, __cb(_, __frame, 2, 19, function ___(__0, __1) { accounts = __1;
        dataLakeStoreUtils.formatOutputList(cli, log, options, accounts); _(); }, true)); }); });


  dataLakeStoreAccount.command("show [accountName]").description($("Shows a Data Lake Store Account based on account name")).usage("[options] <accountName>").option("-n --accountName <accountName>", $("the Data Lake Store account name")).option("-g --resource-group <resource-group>", $("the optional resource group to list the accounts in")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __28(accountName, options, _) { var subscription, client, dataLakeStoreAccount; var __frame = { name: "__28", line: 1102 }; return __func(_, this, arguments, __28, 2, __frame, function __$__28() {






      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      subscription = profile.current.getSubscription(options.subscription);
      client = utils.createDataLakeStoreManagementClient(subscription); return (function __$__28(__then) {

        if (!options.resourceGroup) {
          return getResourceGroupByAccountName(subscription, options.resourceGroup, accountName, __cb(_, __frame, 9, 30, function ___(__0, __1) { options.resourceGroup = __1; __then(); }, true)); } else { __then(); } ; })(function __$__28() {


        return client.account.get(options.resourceGroup, accountName, __cb(_, __frame, 12, 46, function ___(__0, __2) { dataLakeStoreAccount = __2;

          dataLakeStoreUtils.formatOutput(cli, log, options, dataLakeStoreAccount); _(); }, true)); }); }); });


  dataLakeStoreAccount.command("delete [accountName]").description($("Deletes a Data Lake Store Account based on account name")).usage("[options] <accountName>").option("-n --accountName <accountName>", $("the Data Lake Store account name")).option("-g --resource-group <resource-group>", $("the optional resource group to force the command to find the Data Lake Store account to delete in.")).option("-q, --quiet", $("quiet mode (do not ask for delete confirmation)")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __29(accountName, options, _) { var subscription, client; var __frame = { name: "__29", line: 1126 }; return __func(_, this, arguments, __29, 2, __frame, function __$__29() {







      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ; return (function __$__29(_) {


        var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return cli.interaction.confirm(util.format($("Delete Data Lake Store Account %s? [y/n] "), accountName), __cb(_, __frame, 5, 43, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -1125, 17, function ___(__0, __2) { return (function __$__29(__then) { if (__2) { return _(null); } else { __then(); } ; })(function __$__29() {



          subscription = profile.current.getSubscription(options.subscription);
          client = utils.createDataLakeStoreManagementClient(subscription); return (function __$__29(__then) {

            if (!options.resourceGroup) {
              return getResourceGroupByAccountName(subscription, options.resourceGroup, accountName, __cb(_, __frame, 13, 30, function ___(__0, __3) { options.resourceGroup = __3; __then(); }, true)); } else { __then(); } ; })(function __$__29() {


            return client.account.deleteMethod(options.resourceGroup, accountName, __cb(_, __frame, 16, 19, function __$__29() {

              log.info($("Successfully deleted the specified Data Lake Store account.")); _(); }, true)); }); }); }, true)); }); });


  dataLakeStoreAccount.command("create [accountName] [location] [resourceGroup] [defaultGroup] [encryption] [keyVaultId] [keyName] [keyVersion]").description($("Creates a Data Lake Store Account")).usage("[options] <accountName> <location> <resource-group>").option("-n --accountName <accountName>", $("The Data Lake Store account name to create")).option("-l --location <location>", $("the location the Data Lake Store account will be created in. Valid values are: North Central US, South Central US, Central US, West Europe, North Europe, West US, East US, East US 2, Japan East, Japan West, Brazil South, Southeast Asia, East Asia, Australia East, Australia Southeast")).option("-g --resource-group <resource-group>", $("the resource group to create the account in")).option("-d --defaultGroup <defaultGroup>", $("the optional default permissions group to add to the account when created")).option("-e --encryption <'UserManaged'|'ServiceManaged'>", $("optionally indicates what type of encryption to provision the account with, if any. Valid values are UserManaged or ServiceManaged")).option("-k --keyVaultId <key vault id>", $("if the encryption type is UserAssigned, this is the id of the key vault the user wishes to use")).option("-y --keyName <key name>", $("if the encryption type is UserAssigned, this is the key name in the key vault the user wishes to use")).option("-s --keyVersion <key version>", $("if the encryption type is UserAssigned, this is the key version of the key the user wishes to use")).option("-t --tags <tags>", $(("Tags to set to the the Data Lake Store account. Can be mutliple. " + "In the format of 'name=value'. Name is required and value is optional. For example, -t tag1=value1;tag2"))).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __30(accountName, location, resourceGroup, defaultGroup, encryption, keyVaultId, keyName, keyVersion, options, _) { var subscription, tags, config, dataLakeStoreAccount; var __frame = { name: "__30", line: 1161 }; return __func(_, this, arguments, __30, 9, __frame, function __$__30() {














      subscription = profile.current.getSubscription(options.subscription);
      tags = { };
      config = null;
      tags = tagUtils.buildTagsParameter(tags, options);
      if (encryption) {
        config = {
          type: encryption };

        if ((encryption === "UserManaged")) {
          if (((!keyVaultId || !keyName) || !keyVersion)) {
            return _(new Error($("For user managed encryption, --keyVaultId, --keyName and --keyVersion are required parameters and must be supplied."))); } ;


          config.keyVaultMetaInfo = {
            keyVaultResourceId: keyVaultId,
            encryptionKeyName: keyName,
            encryptionKeyVersion: keyVersion }; } else {


          if ((encryption !== "ServiceManaged")) {
            return _(new Error($(("Valid values for --encryption are: 'UserManaged' or 'ServiceManaged'. Value supplied: " + encryption)))); }

           else {
            if (((keyVaultId || keyName) || keyVersion)) {
              log.info($("User supplied Key Vault information. For service managed encryption user supplied Key Vault information is ignored.")); } ; } ; } ;



        options.config = config; } ;


      return createOrUpdateDataLakeStoreAccount(subscription, accountName, resourceGroup, location, tags, options, __cb(_, __frame, 32, 31, function ___(__0, __1) { dataLakeStoreAccount = __1;
        dataLakeStoreUtils.formatOutput(cli, log, options, dataLakeStoreAccount); _(); }, true)); }); });


  dataLakeStoreAccount.command("set [accountName]").description($("Updates the properties of an existing Data Lake Store Account")).usage("[options] <accountName>").option("-n --accountName <accountName>", $("The Data Lake Store account name to update with new tags and/or default permissions group")).option("-g --resource-group <resource-group>", $("the optional resource group to forcibly look for the account to update in")).option("-d --defaultGroup <defaultGroup>", $("the optional default permissions group to set in the existing account")).option("-t --trustedIdProviderState <Enabled|Disabled>", $("optionally enable or disable existing trusted identity providers. Valid values are 'Enabled' or 'Disabled'")).option("-f --firewallState <Enabled|Disabled>", $("optionally enable or disable existing firewall rules. Valid values are 'Enabled' or 'Disabled'")).option("-t --tags <tags>", $(("Tags to set to the Data Lake Store account. Can be mutliple. " + "In the format of 'name=value'. Name is required and value is optional. For example, -t tag1=value1;tag2"))).option("--no-tags", $("remove all existing tags")).option("-s, --subscription <id>", $("the subscription identifier")).execute(function __31(accountName, options, _) { var subscription, client, dataLakeStoreAccount, tags; var __frame = { name: "__31", line: 1209 }; return __func(_, this, arguments, __31, 2, __frame, function __$__31() {












      subscription = profile.current.getSubscription(options.subscription);
      client = utils.createDataLakeStoreManagementClient(subscription); return (function __$__31(__then) {

        if (!options.resourceGroup) {
          return getResourceGroupByAccountName(subscription, options.resourceGroup, accountName, __cb(_, __frame, 5, 30, function ___(__0, __1) { options.resourceGroup = __1; __then(); }, true)); } else { __then(); } ; })(function __$__31() {


        return client.account.get(options.resourceGroup, accountName, __cb(_, __frame, 8, 46, function ___(__0, __2) { dataLakeStoreAccount = __2;

          if (!options.defaultGroup) {
            options.defaultGroup = dataLakeStoreAccount.defaultGroup; } ;


          tags = { };
          if ((!options.tags && (!options.no - tags))) {
            tags = dataLakeStoreAccount.tags; }

           else {
            tags = tagUtils.buildTagsParameter(tags, options); } ;


          return createOrUpdateDataLakeStoreAccount(subscription, accountName, options.resourceGroup, dataLakeStoreAccount.location, tags, options, __cb(_, __frame, 22, 27, function ___(__0, __3) { dataLakeStoreAccount = __3;
            dataLakeStoreUtils.formatOutput(cli, log, options, dataLakeStoreAccount); _(); }, true)); }, true)); }); }); });


  function createOrUpdateDataLakeStoreAccount(subscription, accountName, resourceGroup, location, tags, options, _) { var client, create, accountParams; var __frame = { name: "createOrUpdateDataLakeStoreAccount", line: 1235 }; return __func(_, this, arguments, createOrUpdateDataLakeStoreAccount, 6, __frame, function __$createOrUpdateDataLakeStoreAccount() {
      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;

      if (!location) {
        return _(null, cli.missingArgument("location")); } ;

      if (!resourceGroup) {
        return _(null, cli.missingArgument("resourceGroup")); } ;


      client = utils.createDataLakeStoreManagementClient(subscription);
      create = false; return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$createOrUpdateDataLakeStoreAccount() {

            return client.account.get(resourceGroup, accountName, __cb(_, __frame, 14, 21, __then, true)); }); })(function ___(err, __result) { __catch(function __$createOrUpdateDataLakeStoreAccount() { if (err) {


              create = true; __then(); } else { _(null, __result); } ; }, _); }); })(function ___() { __tryCatch(_, function __$createOrUpdateDataLakeStoreAccount() {


          accountParams = {
            location: location,
            defaultGroup: options.defaultGroup,
            tags: tags }; return (function __$createOrUpdateDataLakeStoreAccount(__then) {


            if (create) {
              if (options.config) {
                accountParams.identity = { };
                accountParams.encryptionConfig = options.config;
                accountParams.encryptionState = "Enabled"; } ;


              return client.account.create(resourceGroup, accountName, accountParams, __cb(_, __frame, 33, 21, __then, true)); } else {


              if (options.firewallState) {
                accountParams.firewallState = options.firewallState; } ;


              if (options.trustedIdProviderState) {
                accountParams.trustedIdProviderState = options.trustedIdProviderState; } ;


              return client.account.update(resourceGroup, accountName, accountParams, __cb(_, __frame, 44, 21, __then, true)); } ; })(function __$createOrUpdateDataLakeStoreAccount() {


            return client.account.get(resourceGroup, accountName, __cb(_, __frame, 47, 26, _, true)); }); }); }); }); };


  function listAllDataLakeStoreAccounts(subscription, resourceGroup, _) { var client, response, accounts; var __frame = { name: "listAllDataLakeStoreAccounts", line: 1285 }; return __func(_, this, arguments, listAllDataLakeStoreAccounts, 2, __frame, function __$listAllDataLakeStoreAccounts() {
      client = utils.createDataLakeStoreManagementClient(subscription); return (function __$listAllDataLakeStoreAccounts(__then) {


        if (!resourceGroup) {
          return client.account.list(__cb(_, __frame, 5, 32, function ___(__0, __1) { response = __1;
            accounts = response; return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$listAllDataLakeStoreAccounts() { __more = false;
                var __6 = response.nextLink; if (__6) {
                  return client.account.listNext(response.nextLink, __cb(_, __frame, 8, 34, function ___(__0, __2) { response = __2;
                    accounts.push.apply(accounts, response); while (__more) { __loop(); }; __more = true; }, true)); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(__then); }, true)); } else {



          return client.account.listByResourceGroup(resourceGroup, __cb(_, __frame, 13, 32, function ___(__0, __3) { response = __3;
            accounts = response; return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$listAllDataLakeStoreAccounts() { __more = false;
                var __9 = response.nextLink; if (__9) {
                  return client.account.listByResourceGroupNext(response.nextLink, __cb(_, __frame, 16, 34, function ___(__0, __4) { response = __4;
                    accounts.push.apply(accounts, response); while (__more) { __loop(); }; __more = true; }, true)); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(__then); }, true)); } ; })(function __$listAllDataLakeStoreAccounts() {



        return _(null, accounts); }); }); };


  function getResourceGroupByAccountName(subscription, resourceGroup, name, _) { var accounts, i, acctId, rgStart, rgEnd; var __frame = { name: "getResourceGroupByAccountName", line: 1309 }; return __func(_, this, arguments, getResourceGroupByAccountName, 3, __frame, function __$getResourceGroupByAccountName() {
      return listAllDataLakeStoreAccounts(subscription, resourceGroup, __cb(_, __frame, 1, 19, function ___(__0, __1) { accounts = __1;
        for (i = 0; (i < accounts.length); i++) {
          if ((accounts[i].name === name)) {
            acctId = accounts[i].id;
            rgStart = (acctId.indexOf("resourceGroups/") + ("resourceGroups/".length));
            rgEnd = acctId.indexOf("/providers/");
            return _(null, acctId.substring(rgStart, rgEnd)); } ; };



        return _(new Error($(((((("Could not find account: " + name) + " in any resource group in subscription: ") + subscription.name) + " with id: ") + subscription.id)))); }, true)); }); };


  function createOrUpdateTrustedIdProvider(cli, accountName, resourceGroup, name, providerEndpoint, options, _) { var subscription, parameters, client, result; var __frame = { name: "createOrUpdateTrustedIdProvider", line: 1323 }; return __func(_, this, arguments, createOrUpdateTrustedIdProvider, 6, __frame, function __$createOrUpdateTrustedIdProvider() {
      if (!accountName) {
        return _(null, cli.missingArgument("accountName")); } ;


      if (!name) {
        return _(null, cli.missingArgument("name")); } ;


      if (!providerEndpoint) {
        return _(null, cli.missingArgument("providerEndpoint")); } ;


      subscription = profile.current.getSubscription(options.subscription); return (function __$createOrUpdateTrustedIdProvider(__then) {
        if (!resourceGroup) {
          return getResourceGroupByAccountName(subscription, resourceGroup, accountName, __cb(_, __frame, 15, 22, function ___(__0, __1) { resourceGroup = __1; __then(); }, true)); } else { __then(); } ; })(function __$createOrUpdateTrustedIdProvider() {


        parameters = {
          idProvider: providerEndpoint };


        client = utils.createDataLakeStoreManagementClient(subscription);
        return client.trustedIdProviders.createOrUpdate(resourceGroup, accountName, name, parameters, __cb(_, __frame, 23, 43, function ___(__0, __2) { result = __2;
          dataLakeStoreUtils.formatOutput(cli, log, options, result); _(); }, true)); }); }); };};
