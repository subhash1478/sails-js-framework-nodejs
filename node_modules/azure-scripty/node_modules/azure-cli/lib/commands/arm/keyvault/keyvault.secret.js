/*** Generated by streamline 0.10.17 (callbacks) - DO NOT EDIT ***/ "use strict"; var __rt=require('streamline/lib/callbacks/runtime').runtime(__filename, false),__func=__rt.__func,__cb=__rt.__cb,__tryCatch=__rt.__tryCatch; var util = require("util");




















var fs = require("fs");

var profile = require("../../../util/profile");
var utils = require("../../../util/utils");
var kvUtils = require("./kv-utils");

var $ = utils.getLocaleString;


var TEXT_FILE_ENCODINGS = ["utf8","utf16le","ucs2","ascii",];
var BINARY_FILE_ENCODINGS = ["base64","hex",];

exports.init = function(cli) {
  var log = cli.output;

  var secret = cli.category("keyvault").category("secret").description($("Commands to manage secrets in the Azure Key Vault service"));


  secret.command("list [vault-name]").description($("Lists secrets of a vault")).usage("[options] <vault-name>").option("-u, --vault-name <vault-name>", $("the vault name")).execute(function __1(vaultName, options, _) { var client, secrets, progress, result; var __frame = { name: "__1", line: 44 }; return __func(_, this, arguments, __1, 2, __frame, function __$__1() {









      log.verbose(("arguments: " + JSON.stringify({
        vaultName: vaultName,
        options: options })));


      options.vaultName = (options.vaultName || vaultName);

      if (!options.vaultName) {
        return _(null, cli.missingArgument("vault-name")); } ;






      options.vaultUri = createVaultUri(options);
      client = createClient(options);
      secrets = [];
      progress = cli.interaction.progress(util.format($("Loading secrets of vault %s"), options.vaultUri)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__1() {

            return client.getSecrets(options.vaultUri, null, __cb(_, __frame, 26, 28, function ___(__0, __1) { result = __1; return (function __$__1(__then) {
                if (result) {
                  secrets = result; return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$__1() { __more = false;

                      var __4 = (result && result.nextLink); if (__4) {
                        log.verbose(util.format($("Found %d secrets, loading more"), secrets.length));
                        return client.getSecretsNext(result.nextLink, __cb(_, __frame, 32, 28, function ___(__0, __2) { result = __2;
                          if (result) {
                            secrets = secrets.concat(result); } ; while (__more) { __loop(); }; __more = true; }, true)); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(__then); } else { __then(); } ; })(function __$__1() { _(null, null, true); }); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__1() {




              progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__1() {


          log.table(secrets, showSecretRow);

          log.info(util.format($("Found %d secrets"), secrets.length)); _(); }); }); }); });


  secret.command("list-versions [vault-name] [secret-name]").description($("Lists secret versions")).usage("[options] <vault-name> [secret-name]").option("-u, --vault-name <vault-name>", $("the vault name")).option("-s, --secret-name <secret-name>", $("lists only versions of this secret")).execute(function __2(vaultName, secretName, options, _) { var client, secrets, secretIdentifier, secretVersions, progress, result, i, j; var __frame = { name: "__2", line: 96 }; return __func(_, this, arguments, __2, 3, __frame, function __$__2() {










      log.verbose(("arguments: " + JSON.stringify({
        vaultName: vaultName,
        secretName: secretName,
        options: options })));


      options.vaultName = (options.vaultName || vaultName);
      options.secretName = (options.secretName || secretName);

      if (!options.vaultName) {
        return _(null, cli.missingArgument("vault-name")); } ;






      options.vaultUri = createVaultUri(options);
      client = createClient(options); return (function __$__2(__then) {



        if (!options.secretName) {
          secrets = [];
          progress = cli.interaction.progress(util.format($("Loading secrets of vault %s"), options.vaultUri)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__2() {

                return client.getSecrets(options.vaultUri, null, __cb(_, __frame, 32, 30, function ___(__0, __1) { result = __1; return (function __$__2(__then) {
                    if ((result && result.length)) {
                      i = 0; var __8 = false; return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$__2() { __more = false; if (__8) { ++i; } else { __8 = true; } ; var __7 = (i < result.length); if (__7) {
                            secretIdentifier = kvUtils.parseSecretIdentifier(result[i].id);
                            return getSecretVersions(client, secretIdentifier.vaultUri, secretIdentifier.name, __cb(_, __frame, 36, 31, function ___(__0, __2) { secretVersions = __2;
                              secrets = secrets.concat(secretVersions); while (__more) { __loop(); }; __more = true; }, true)); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(function __$__2() { return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$__2() { __more = false;


                            var __10 = (result && result.nextLink); if (__10) {
                              log.verbose(util.format($("Found %d secrets, loading more"), secrets.length));
                              return client.getSecretsNext(result.nextLink, __cb(_, __frame, 42, 30, function ___(__0, __3) { result = __3; return (function __$__2(__then) {
                                  if ((result && result.length)) {
                                    j = 0; var __13 = false; return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$__2() { __more = false; if (__13) { ++j; } else { __13 = true; } ; var __12 = (j < result.length); if (__12) {
                                          secretIdentifier = kvUtils.parseSecretIdentifier(result[j].id);
                                          return getSecretVersions(client, secretIdentifier.vaultUri, secretIdentifier.name, __cb(_, __frame, 46, 35, function ___(__0, __4) { secretVersions = __4;
                                            secrets = secrets.concat(secretVersions); while (__more) { __loop(); }; __more = true; }, true)); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(__then); } else { __then(); } ; })(function __$__2() { while (__more) { __loop(); }; __more = true; }); }, true)); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(__then); }); } else { __then(); } ; })(function __$__2() { _(null, null, true); }); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__2() {





                  progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, __then); }); } else {


          progress = cli.interaction.progress(util.format($("Loading secrets of vault %s"), options.vaultUri)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__2() {

                return getSecretVersions(client, options.vaultUri, options.secretName, __cb(_, __frame, 58, 20, function ___(__0, __5) { secrets = __5; _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__2() {

                  progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, __then); }); } ; })(function __$__2() {



        log.table(secrets, showSecretRow);

        log.info(util.format($("Found %d secrets"), secrets.length)); _(); }); }); });


  secret.command("set [vault-name] [secret-name] [secret-value]").description($("Stores a secret on the vault")).usage("options <vault-name> <secret-name>").option("-u, --vault-name <vault-name>", $("the vault name")).option("-s, --secret-name <secret-name>", $("name of the secret to be created; if already exists, a new secret version is created")).option("-w, --value <secret-value>", $("the secret value to be uploaded, expressed as an arbitrary sequence of characters; cannot be used along with --json-value or --file flags")).option("--json-value <JSON-string>", $("the secret value to be uploaded, expressed as a JSON string; cannot be used along with --value or --file flags")).option("--file <file-name>", $("the file that contains the secret value to be uploaded; cannot be used along with the --value or --json-value flag")).option("--file-encoding <encoding>", util.format($("for text files, specifies encoding used on the file; valid values: [%s]; default is %s"), TEXT_FILE_ENCODINGS.join(", "), TEXT_FILE_ENCODINGS[0])).option("--encode-binary <encoding>", util.format($("tells the file is binary and encodes it before uploading; valid values: [%s]"), BINARY_FILE_ENCODINGS.join(", "))).option("-c, --content-type <content-type>", $("the content type")).option("--enabled <boolean>", $("tells if the secret should be enabled; valid values: [false, true]; default is true")).option("-e, --expires <datetime>", $("expiration time of secret, expressed in RFC-1123/ISO8601 date format")).option("-n, --not-before <datetime>", $("time before which secret cannot be used, expressed in RFC-1123/ISO8601 date format")).option("-t, --tags <tags>", $("Tags to set on the secret. Can be multiple in the format 'name=value'. Name is required and value is optional. For example, -t tag1=value1;tag2")).execute(function __3(vaultName, secretName, secretValue, options, _) { var secretVersion, client, requestOptions, secret, secretIdentifier, progress; var __frame = { name: "__3", line: 180 }; return __func(_, this, arguments, __3, 4, __frame, function __$__3() {





















      parseSecretPropertiesArguments(vaultName, secretName, secretVersion, options);
      parseSecretValue(secretValue, options);





      options.vaultUri = createVaultUri(options);
      client = createClient(options);

      requestOptions = {
        tags: options.tags,
        contentType: options.contentType,
        secretAttributes: {
          enabled: options.enabled,
          notBefore: options.notBefore,
          expires: options.expires } };



      log.verbose(("request options: " + JSON.stringify(requestOptions)));


      secretIdentifier = getSecretIdentifier(options);
      progress = cli.interaction.progress(util.format($("Creating secret %s"), secretIdentifier)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__3() {

            return client.setSecret(options.vaultUri, options.secretName, options.value, requestOptions, __cb(_, __frame, 33, 24, function ___(__0, __1) { secret = __1; _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__3() {

              progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__3() {


          showSecret(options, secret); _(); }); }); }); });



  secret.command("set-attributes [vault-name] [secret-name] [secret-version]").description($("Changes attributes of an existing secret")).usage("[options] <vault-name> <secret-name> [secret-version]").option("-u, --vault-name <vault-name>", $("the vault name")).option("-s, --secret-name <secret-name>", $("name of the secret to be modified")).option("-r, --secret-version <secret-version>", $("the version to be modified; if omited, modifies only the most recent")).option("-c, --content-type <content-type>", $("the content type")).option("--enabled <boolean>", $("if informed, command will change the enabled state; valid values: [false, true]")).option("-e, --expires <datetime>", $("if informed, command will change secret expiration time; expressed in RFC-1123/ISO8601 date format, or null to clear the value")).option("-n, --not-before <datetime>", $("if informed, command will change time before which secret cannot be used; expressed in RFC-1123/ISO8601 date format, or null to clear the value")).option("-t, --tags <tags>", $("Tags to set on the secret. Can be multiple in the format 'name=value'. Name is required and value is optional. For example, -t tag1=value1;tag2")).option("--reset-tags", $("remove previously existing tags; can combined with --tags")).execute(function __4(vaultName, secretName, secretVersion, options, _) { var informed, client, secret, secretIdentifier, currentTags, requestOptions, progress; var __frame = { name: "__4", line: 234 }; return __func(_, this, arguments, __4, 4, __frame, function __$__4() {


















      informed = {
        enabled: (options.enabled || false),
        expires: (options.expires || false),
        notBefore: (options.notBefore || false),
        secretOps: (options.secretOps || false),
        tags: (options.tags || false),
        resetTags: (options.resetTags || false) };


      parseSecretPropertiesArguments(vaultName, secretName, secretVersion, options);





      options.vaultUri = createVaultUri(options);
      client = createClient(options);


      secretIdentifier = getSecretIdentifier(options); return (function __$__4(__then) {

        if (informed.tags) { return (function __$__4(__then) {



            if (!informed.resetTags) {


              log.info(util.format($("Getting secret %s"), secretIdentifier));
              return client.getSecret(secretIdentifier, __cb(_, __frame, 36, 26, function ___(__0, __1) { secret = __1;
                currentTags = secret.tags;
                if (!currentTags) {

                  currentTags = { }; } ;

                options.tags = kvUtils.mergeTags(currentTags, options.tags); __then(); }, true)); } else { __then(); } ; })(__then); } else {







          if (informed.resetTags) {


            informed.tags = true;
            options.tags = { }; } ; __then(); } ; })(function __$__4() {









        requestOptions = {
          secretAttributes: { } };



        if (informed.secretOps) { requestOptions.secretOps = options.secretOps; } ;
        if (informed.enabled) { requestOptions.secretAttributes.enabled = options.enabled; } ;
        if (informed.notBefore) { requestOptions.secretAttributes.notBefore = options.notBefore; } ;
        if (informed.expires) { requestOptions.secretAttributes.expires = options.expires; } ;
        if (informed.tags) { requestOptions.tags = options.tags; } ;





        log.verbose(("request options: " + JSON.stringify(requestOptions, null, " ")));

        progress = cli.interaction.progress(util.format($("Updating secret %s"), secretIdentifier)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__4() {

              return client.updateSecret(secretIdentifier, requestOptions, __cb(_, __frame, 83, 24, function ___(__0, __2) { secret = __2; _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__4() {

                progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__4() {


            delete secret.value;
            showSecret(options, secret); _(); }); }); }); }); });


  secret.command("show [vault-name] [secret-name] [secret-version]").description($("Shows a vault secret")).usage("[options] <vault-name> <secret-name> [secret-version]").option("-u, --vault-name <vault-name>", $("the vault name")).option("-s, --secret-name <secret-name>", $("the secret name")).option("-r, --secret-version <secret-version>", $("the secret version; if omited, uses the most recent")).execute(function __5(vaultName, secretName, secretVersion, options, _) { var client, secretIdentifier, progress; var __frame = { name: "__5", line: 332 }; return __func(_, this, arguments, __5, 4, __frame, function __$__5() {











      options.vaultName = (options.vaultName || vaultName);
      options.secretName = (options.secretName || secretName);
      options.secretVersion = (options.secretVersion || secretVersion);

      if (!options.vaultName) {
        return _(null, cli.missingArgument("vault-name")); } ;


      if (!options.secretName) {
        return _(null, cli.missingArgument("secret-name")); } ;






      options.vaultUri = createVaultUri(options);
      client = createClient(options);

      secretIdentifier = getSecretIdentifier(options);
      progress = cli.interaction.progress(util.format($("Getting secret %s"), secretIdentifier)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__5() {

            return client.getSecret(secretIdentifier, __cb(_, __frame, 28, 24, function ___(__0, __1) { secret = __1; _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__5() {

              progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__5() {


          showSecret(options, secret); _(); }); }); }); });


  secret.command("get [vault-name] [secret-name] [secret-version] [file]").description($("Downloads a secret from the vault")).usage("[options] <vault-name> <secret-name> [secret-version] <file>").option("-u, --vault-name <vault-name>", $("the vault name")).option("-s, --secret-name <secret-name>", $("the secret name")).option("-r, --secret-version <secret-version>", $("the secret version; if omited, uses the most recent")).option("--file <file-name>", $("the file to receive secret contents; the file must not exist otherwise the command fails")).option("--file-encoding <encoding>", util.format($("specifies how to encode the secret contents in the file; valid values: [%s]; default is %s"), TEXT_FILE_ENCODINGS.join(", "), TEXT_FILE_ENCODINGS[0])).option("--decode-binary <encoding>", util.format($("tells to write a binary file by decoding secret contents with the informed encoding; valid values: [%s]"), BINARY_FILE_ENCODINGS.join(", "))).execute(function __6(vaultName, secretName, secretVersion, file, options, _) { var client, secretIdentifier, progress, minLength, data; var __frame = { name: "__6", line: 377 }; return __func(_, this, arguments, __6, 5, __frame, function __$__6() {














      options.vaultName = (options.vaultName || vaultName);
      options.secretName = (options.secretName || secretName);
      options.secretVersion = (options.secretVersion || secretVersion);
      options.file = (options.file || file);

      if (!options.vaultName) {
        return _(null, cli.missingArgument("vault-name")); } ;


      if (!options.secretName) {
        return _(null, cli.missingArgument("secret-name")); } ;


      if (!options.file) {
        return _(null, cli.missingArgument("file")); } ;


      if ((options.fileEncoding && options.decodeBinary)) {
        log.error($("The following options cannot be used together:"));
        log.error($("    --file-encoding <encoding>"));
        log.error($("    --decode-binary <encoding>"));
        return _(new Error($("Unable to determine file format."))); } ;


      if (options.decodeBinary) {
        options.decodeBinary = kvUtils.parseEnumArgument("decode-binary", options.decodeBinary, BINARY_FILE_ENCODINGS); }
       else {
        options.fileEncoding = kvUtils.parseEnumArgument("file-encoding", options.fileEncoding, TEXT_FILE_ENCODINGS, TEXT_FILE_ENCODINGS[0]); } ;






      options.vaultUri = createVaultUri(options);
      client = createClient(options);

      secretIdentifier = getSecretIdentifier(options);
      progress = cli.interaction.progress(util.format($("Getting secret %s"), secretIdentifier)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__6() {

            return client.getSecret(secretIdentifier, __cb(_, __frame, 46, 24, function ___(__0, __1) { secret = __1; _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__6() {

              progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__6() {


          log.info(util.format($("Writing secret to %s"), options.file));

          if (!options.decodeBinary) {


            fs.writeFileSync(options.file, secret.value, { encoding: options.fileEncoding, flag: "wx" }); } else {

            if ((secret.value.length > 0)) {



              minLength = 0;
              if ((options.decodeBinary == "base64")) {

                minLength = ((Math.floor((secret.value.length / 4)) * 3) - 2); } else {
                if ((options.decodeBinary == "hex")) {
                  minLength = Math.ceil((secret.value.length / 2)); } ; } ;


              data = Buffer.from(secret.value, options.decodeBinary);
              if (((!data || !data.length) || (data.length < minLength))) {
                return _(new Error(util.format($("The secret value doesn't appear to be %s-encoded. You cannot use --decode-binary %s with this secret value."), options.decodeBinary, options.decodeBinary))); } ;


              fs.writeFileSync(options.file, data, { flag: "wx" }); }

             else {


              fs.writeFileSync(options.file, Buffer.alloc(0)); } ; } ; _(); }); }); }); });





  secret.command("delete [vault-name] [secret-name]").description($("Deletes a secret from the vault")).usage("[options] <vault-name> <secret-name>").option("-u, --vault-name <vault-name>", $("the vault name")).option("-s, --secret-name <secret-name>", $("the secret name")).option("-q, --quiet", $("quiet mode (do not ask for delete confirmation)")).execute(function __7(vaultName, secretName, options, _) { var client, secret, progress; var __frame = { name: "__7", line: 469 }; return __func(_, this, arguments, __7, 3, __frame, function __$__7() {











      log.verbose(("arguments: " + JSON.stringify({
        vaultName: vaultName,
        secretName: secretName,
        options: options })));


      options.vaultName = (options.vaultName || vaultName);
      options.secretName = (options.secretName || secretName);

      if (!options.vaultName) {
        return _(null, cli.missingArgument("vault-name")); } ;


      if (!options.secretName) {
        return _(null, cli.missingArgument("secret-name")); } ; return (function __$__7(_) {


        var __1 = !options.quiet; if (!__1) { return _(null, __1); } ; return cli.interaction.confirm(util.format($("Delete secret %s from vault %s? [y/n] "), options.secretName, options.vaultName), __cb(_, __frame, 23, 45, function ___(__0, __3) { var __2 = !__3; return _(null, __2); }, true)); })(__cb(_, __frame, -468, 17, function ___(__0, __2) { return (function __$__7(__then) { if (__2) {
            return _(new Error($("Aborted by user"))); } else { __then(); } ; })(function __$__7() {






          options.vaultUri = createVaultUri(options);
          client = createClient(options);


          progress = cli.interaction.progress(util.format($("Deleting secret %s from vault %s"), options.secretName, options.vaultName)); return (function ___(__then) { (function ___(_) { __tryCatch(_, function __$__7() {

                return client.deleteSecret(options.vaultUri, options.secretName, __cb(_, __frame, 37, 24, function ___(__0, __3) { secret = __3; _(null, null, true); }, true)); }); })(function ___(__e, __r, __cont) { (function ___(__then) { __tryCatch(_, function __$__7() {

                  progress.end(); __then(); }); })(function ___() { __tryCatch(_, function ___() { if (__cont) { __then(); } else { _(__e, __r); }; }); }); }); })(function ___() { __tryCatch(_, function __$__7() {


              showSecret(options, secret); _(); }); }); }); }, true)); }); });


  function createVaultUri(options) {
    var subscription = profile.current.getSubscription(options.subscription);
    return (("https://" + options.vaultName) + subscription.keyVaultDnsSuffix); };


  function createClient(options) {
    var subscription = profile.current.getSubscription(options.subscription);
    log.verbose(util.format($("Using subscription %s (%s)"), subscription.name, subscription.id));
    return utils.createKeyVaultClient(subscription); };


  function getSecretIdentifier(options) {
    var id = ((options.vaultUri + "/secrets/") + options.secretName);
    if (options.secretVersion) {
      id += ("/" + options.secretVersion); } ;

    return id; };


  function parseSecretValue(secretValue, options) {

    var informed = [];
    if (secretValue) { informed.push($("    [secret-value]")); };
    if (options.value) { informed.push($("    -w, --value <secret-value>")); };
    if (options.jsonValue) { informed.push($("    --json-value <JSON-string>")); };
    if (options.file) { informed.push($("    --file <file-name>")); };

    if ((informed.length > 1)) {
      log.error($("The following flags cannot be used together:"));
      for (var i = 0; (i < informed.length); ++i) {
        log.error(informed[i]); };

      throw new Error($("Unable to determine the secret value.")); } ;


    if ((informed.length === 0)) {
      log.error($("Please inform at least one of the following:"));
      log.error($("    [secret-value]"));
      log.error($("    -w, --value <secret-value>"));
      log.error($("    --json-value <JSON-string>"));
      log.error($("    --file <file-name>"));
      throw new Error($("Unable to determine the secret value.")); } ;


    if ((!options.file && options.fileEncoding)) {
      log.error($("Flag --file-encoding can only be used with --file."));
      throw new Error($("Inconsistent parameters.")); } ;


    if ((!options.file && options.encodeBinary)) {
      log.error($("Flag --encode-binary can only be used with --file."));
      throw new Error($("Inconsistent parameters.")); } ;


    if ((options.fileEncoding && options.encodeBinary)) {
      log.error($("The following options cannot be used together:"));
      log.error($("    --file-encoding <encoding>"));
      log.error($("    --encode-binary <encoding>"));
      throw new Error($("Unable to determine file format.")); } ;


    if (secretValue) {

      options.value = secretValue; }


     else if (options.jsonValue) {

      options.value = kvUtils.parseJsonStringArgument("json-value", options.jsonValue); }

     else if (options.file) {

      if (!options.encodeBinary) {

        options.fileEncoding = kvUtils.parseEnumArgument("file-encoding", options.fileEncoding, TEXT_FILE_ENCODINGS, TEXT_FILE_ENCODINGS[0]);
        options.value = fs.readFileSync(options.file, { encoding: options.fileEncoding }); }

       else {

        options.encodeBinary = kvUtils.parseEnumArgument("encode-binary", options.encodeBinary, BINARY_FILE_ENCODINGS);
        options.value = fs.readFileSync(options.file, { encoding: options.encodeBinary }); } ; }   ;





    if (!options.value) {
      throw new Error("Error parsing secret value from options"); } ; };




  function parseSecretPropertiesArguments(vaultName, secretName, secretVersion, options) {

    log.verbose(("arguments: " + JSON.stringify({
      vaultName: vaultName,
      secretName: secretName,
      secretVersion: secretVersion,
      options: options })));


    options.vaultName = (options.vaultName || vaultName);
    options.secretName = (options.secretName || secretName);
    options.secretVersion = (options.secretVersion || secretVersion);

    if (!options.vaultName) {
      return cli.missingArgument("vault-name"); } ;


    if (!options.secretName) {
      return cli.missingArgument("secret-name"); } ;


    options.enabled = kvUtils.parseBooleanArgument("enabled", options.enabled, true);
    options.tags = kvUtils.parseTagsArgument("tags", options.tags); };



  function getSecretVersions(client, vaultUri, secretName, _) { var secrets, result; var __frame = { name: "getSecretVersions", line: 632 }; return __func(_, this, arguments, getSecretVersions, 3, __frame, function __$getSecretVersions() {

      log.verbose(util.format($("Loading versions of secret %s"), secretName));

      secrets = [];
      return client.getSecretVersions(vaultUri, secretName, null, __cb(_, __frame, 5, 24, function ___(__0, __1) { result = __1; return (function __$getSecretVersions(__then) {
          if (result) {
            secrets = result; return (function ___(__break) { var __more; var __loop = __cb(_, __frame, 0, 0, function __$getSecretVersions() { __more = false;

                var __4 = (result && result.nextLink); if (__4) {
                  log.verbose(util.format($("Found %d versions, loading more"), secrets.length));
                  return client.getSecretVersionsNext(result.nextLink, __cb(_, __frame, 11, 24, function ___(__0, __2) { result = __2;
                    if (result) {
                      secrets = secrets.concat(result); } ; while (__more) { __loop(); }; __more = true; }, true)); } else { __break(); } ; }); do { __loop(); } while (__more); __more = true; })(__then); } else { __then(); } ; })(function __$getSecretVersions() {




          return _(null, secrets); }); }, true)); }); };


  function showSecret(options, secret) {
    cli.interaction.formatOutput(secret, function(secret) {
      secret.attributes = kvUtils.getAttributesWithPrettyDates(secret.attributes);
      utils.logLineFormat(secret, log.data); }); };



  function showSecretRow(row, item) {
    var identifier = kvUtils.parseSecretIdentifier(item.id);


    row.cell($("Name"), identifier.name);
    if (identifier.version) {
      row.cell($("Version"), identifier.version); } ;

    row.cell($("Enabled"), item.attributes.enabled);
    var attributes = kvUtils.getAttributesWithPrettyDates(item.attributes);
    row.cell($("Not Before"), (attributes.notBefore || ""));
    row.cell($("Expires"), (attributes.expires || ""));
    row.cell($("Created"), attributes.created);
    row.cell($("Updated"), attributes.updated);
    row.cell($("Tags"), kvUtils.getTagsInfo(item.tags)); };};
